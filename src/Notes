О Vue
======
Vue использует синтаксис шаблонов на основе HTML, который позволяет декларативно связывать визуализируемый DOM с данными базового экземпляра компонента. Все шаблоны Vue представляют собой синтаксически корректный HTML, который может быть разобран браузерами и HTML-парсерами, соответствующими спецификации.

Под капотом Vue компилирует шаблоны в высокооптимизированный код JavaScript. В сочетании с системой реактивности Vue может интеллектуально определить минимальное количество компонентов для повторного отображения и применить минимальное количество манипуляций с DOM при изменении состояния приложения.

v-bind
======

Директива v-bind предписывает Vue поддерживать атрибут id элемента в синхронизации со свойством dynamicId компонента. Если связанное значение равно null или undefined, то атрибут будет удален из отображаемого элемента.

Булевы атрибуты - это атрибуты, которые своим присутствием в элементе могут указывать на истинное / ложное значение. Например, disabled является одним из наиболее часто используемых булевых атрибутов.

В этом случае v-bind работает немного по-другому:

<button :disabled="isButtonDisabled">Кнопка</button>.

Атрибут disabled будет включен, если isButtonDisabled имеет значение true. Он также будет включен, если значение является пустой строкой, поддерживая согласованность с <button disabled="">. Для других ложных значений атрибут будет опущен.


//Внутри {{ }} можно вызывать функции. Функции, вызываемые внутри выражений привязки, будут вызываться каждый раз при обновлении компонента, поэтому они не должны иметь никаких побочных эффектов, таких как изменение данных или запуск асинхронных операций.

//Такое нельзя помещать в {{}}:

<!-- это утверждение, а не выражение: -->
{{ var a = 1 }}

<!-- управление потоком тоже не работает, используйте троичные выражения -->
{{ if (ok) { return message } }}

//Директивы - это специальные атрибуты с префиксом v-. Vue предоставляет ряд встроенных директив, включая v-html и v-bind, которые мы представили выше.

Ожидается, что значения атрибутов директив будут представлять собой отдельные выражения JavaScript (за исключением v-for, v-on и v-slot, которые будут рассмотрены в соответствующих разделах позже). Задача директивы - реактивно применять обновления к DOM при изменении значения выражения. 

//Указывать this. каждый, когда обращаемся к парметрам из data 
//input + v-model + type в template = Окошко, куда можно вводить текст
//Если нужно следить за действиями пользователя - используем computed, если нет - methods. Для кликов, лучше методы. Компьютед для вычисляемых, методы для невычисляемых.
//В Дата можно хранить boolean значения и использовать их в директиве v-if. Boolean в data можно менять с помощью методов и компьтедов. Напрмер, через !, который сделает значение противоположным.
//Функции в created выполняются до отрисовки, а в mounted после отрисовки. Получается, created выполняется быстрее.
//<ul>
  <li v-for="user in users" :key="user">
      <p>{{ user }}</p>
  </li>
//</ul> - Сделать список с точками

//<input v-model="text" type="text"></input> //Сделать окошечко, куда можно вводить текст

//Если ключ и значения совпадают, то можно опускать всё до ключа

AddNote () {
    let {title, descr} = this.note
    this.notes.push({
      title,
      descr
    })

//Как добавить папку на сервере? - ЕЩЁ  ПОЧИТАТЬ ОБ ЭТОЙ ШТУКЕ. Видео 21.

В package.json:

const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  publicPath: process.env.NODE_ENV === 'production' 
  ? '/modals/' - Папка на сервере, куда будут добавлены элементы проекта (картинки и css). Это если надо открыть чере run serve, если хочется открыть через index.html, то пишется так: ? ''. ДЛЯ ОТКРЫТИЯ НА СЕРВЕРЕ ВСЕГДА ПИШЕМ СЛЭШ 
  : '/'
})

Если не надо, чтобы картинки и css лежали на сервере, то можно создать папку assets. Это делается с помощью: 

module.exports = defineConfig({
assetsDir: 'assets' - далее запускается run build
})

ПОЧИТАТЬ про chunk-vendors.a3756fa9.js.map
+ что такое хэши 

app.656f88c8.js - отвечает за хеширование

npm i - с помощью этой команды можно узнать актуальные версии, а также ошибки, которые  есть

Как удалить пакет из package-lock?
---------------------------------

npm uninstall *название пакета*

Параметр default
----------------

* Отрабатывает "по умолчанию", тогда, когда ни один параметр не задан.

Props
-----

Если хотим просто пердать сообщение, которое поместим в кавычки messege="hello message", тогда байндить пропсы не надо.

Если хотим получить сообщение через параметр из даты, нужно байндить: :messege="messege".

Emit
----

#Поведение в 2.x

Во Vue 2 можно объявлять входные параметры, которые компонент получает, но нет возможности объявить какие события он может генерировать:

<template>
  <div>
    <p>{{ text }}</p>
    <button @click="$emit('accepted')">OK</button>
  </div>
</template>

<script>
  export default {
    props: ['text']
  }
</script>

#Поведение в 3.x

Аналогично входным параметрам, теперь можно определить события которые генерирует компонент с помощью опции emits:

<template>
  <div>
    <p>{{ text }}</p>
    <button @click="$emit('accepted')">OK</button>
  </div>
</template>

<script>
  export default {
    props: ['text'],
    emits: ['accepted']
  }
</script>

Опция также принимает объект, что позволяет указать валидаторы для аргументов, которые передаются вместе с генерируемым событием, аналогично валидации при объявлении props.

SCC
---

<style lang="scss" scoped> — Параметры ниже будут применяться только к html элементам на этой странице

cursor: pointer - При наведении на элемент мышка будет меняться на указатель 

//Чтобы кнопки загорались при наведении нужно:
1) Задать параметр: с тру в Дата
2) Через :class="{ active: grid }" для конкретной иконки, то есть, когда класс актив равен Грид иконка активна.
3) @click="grid = true" При клике грид приобретает значение true.
4) Прописать в css настройки (???)

//Как сделать так, чтобы в строку поиска можно было что-то ввести?

@search="search = $event" 

Метод @search, который был записан в watch: 

    search (val) {
      // console.log(val)
      this.$emit('search', val);
    }

+

search из Дата равняется ранодмному событию.

То есть метод этот событие, которые мы транслируем через Дату.


v-if/v-show
-----------

* v-if убирает элемент из ДОМ-дерева и не показывает на странице
* v-show отображает элемент в дом-дереве и не показывает на странице 

Options API vs. Composition API
===============================

В Options изменяется HTML — изменяются данные и наоборот. 

Options построен вокруг HTML-шаблона.  В data, metods и тд — схема, по которой надо собрать this.

Vue3 разделил Vue на три части (примерно):

1. Система реактивности: ref и computed меняются через watch на любом языке, напр, jQuery

2. Отрисовка шаблонов Vue + обеспечение связи с реактивностью

3. Компилятор. Vue превращает html в рендер-функцию

У Composition API нет чёткой структуры, как у Options API.

Хуки
====

Функции с помощью которых можно написать обработик события.

Каждый экземпляр компонента Vue при создании проходит ряд шагов инициализации - например, ему необходимо настроить наблюдение за данными, скомпилировать шаблон, смонтировать экземпляр в DOM и обновить DOM при изменении данных. По пути он также запускает функции, называемые крючками (хуками) жизненного цикла, предоставляя пользователям возможность добавлять свой собственный код на определенных этапах.

Реактивность
============

* Способность фреймворка реагировать на изменения в данных.

Самая частая реакция на обновление данных: Система Vue отследила изменения в данных и автоматически перерисовала их отображение. 

